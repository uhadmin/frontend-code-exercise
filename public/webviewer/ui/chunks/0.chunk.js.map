{"version":3,"sources":["webpack:///./src/ui/node_modules/@pdftron/webviewer-react-toolkit/dist/esm/hooks/useFocusTrap.js","webpack:///./src/ui/node_modules/@pdftron/webviewer-react-toolkit/dist/esm/hooks/useCurrentRef.js","webpack:///./src/ui/node_modules/@pdftron/webviewer-react-toolkit/dist/esm/components/FocusTrap/FocusTrap.js"],"names":["useFocusTrap","locked","options","focusLastOnUnlock","focusRef","getFocusableElements","current","querySelectorAll","lockFocus","event","key","focusableElements","length","preventDefault","focusedItemIndex","findFocusableIndex","document","activeElement","shiftKey","focus","checkFocus","_a","target","blur","window","addEventListener","removeEventListener","toRef","toRefRef","focusLastOnUnlockRef","lastFocusedElement","contains","elements","toFind","index","i","FocusTrap","children","ref"],"mappings":"kJAUO,SAASA,EAAaC,EAAQC,QAClB,IAAXD,IAAqBA,GAAS,QAClB,IAAZC,IAAsBA,EAAU,IACpC,IAAIC,EAAoBD,EAAQC,kBAC5BC,EAAW,iBAAO,MAGlBC,EAAuB,uBAAY,WACnC,OAAOD,EAASE,QAAQC,iBAAiB,OAC1C,IAGCC,EAAY,uBAAY,SAAUC,GAElC,GAAKR,KAAWQ,GAAuB,QAAdA,EAAMC,MAAmBN,EAASE,QAA3D,CAEA,IAAIK,EAAoBN,IAExB,IAAKM,EAAkBC,OACnB,OAAOH,aAAqC,EAASA,EAAMI,iBAC/D,IAAIC,EAAmBC,EAAmBJ,EAAmBK,SAASC,eAEtE,IAA0B,IAAtBH,GAA4BL,EAGhC,OAA0B,IAAtBK,KAA8BL,aAAqC,EAASA,EAAMS,WAAaJ,IAAqBH,EAAkBC,OAAS,GAC/ID,EAAkB,GAAGQ,QACdV,aAAqC,EAASA,EAAMI,mBAG1DJ,aAAqC,EAASA,EAAMS,WAAkC,IAArBJ,GAClEH,EAAkBA,EAAkBC,OAAS,GAAGO,QACzCV,aAAqC,EAASA,EAAMI,uBAF/D,KAID,CAACR,EAAsBJ,IAGtBmB,EAAa,uBAAY,SAAUX,GACnC,IAAIY,EAEJ,GAAKpB,GAAWG,EAASE,QAAzB,CAGA,IAAIK,EAAoBN,IACxB,OAAKM,EAAkBC,QAIG,IADHG,EAAmBJ,EAAmBF,EAAMa,QAExDX,EAAkB,GAAGQ,aADhC,EAHmC,QAAvBE,EAAKZ,EAAMa,cAA2B,IAAPD,OAAgB,EAASA,EAAGE,UAKxE,CAAClB,EAAsBJ,IAE1B,qBAAU,WACN,GAAsB,oBAAXuB,OAIX,OAFAR,SAASS,iBAAiB,UAAWjB,GACrCQ,SAASS,iBAAiB,UAAWL,GAC9B,WACHJ,SAASU,oBAAoB,UAAWlB,GACxCQ,SAASU,oBAAoB,UAAWN,MAE7C,CAACA,EAAYZ,IAEhB,ICxE0BmB,EACtBC,EDuEAC,GCxEsBF,EDwEexB,ECvErCyB,EAAW,iBAAOD,GACtB,qBAAU,WACNC,EAAStB,QAAUqB,KAEhBC,GDuFP,OAfA,qBAAU,WACN,IAAIP,EAGAS,EAFJ,GAAsB,oBAAXN,QAGPvB,EAAQ,CACR,GAAI4B,EAAqBvB,WAAyC,QAA3Be,EAAKjB,EAASE,eAA4B,IAAPe,OAAgB,EAASA,EAAGU,SAASf,SAASC,gBAGpH,OAFAa,EAAqBd,SAASC,cAC9BT,IACO,WAAc,OAAOsB,EAAmBX,SAEnDX,OAGL,CAACqB,EAAsBrB,EAAWP,IAC9BG,EAEJ,SAASW,EAAmBiB,EAAUC,GACzC,IAAIC,GAAS,EACb,IAAKD,EACD,OAAOC,EACX,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAASpB,OAAQuB,IACjC,GAAIH,EAASG,KAAOF,EAAQ,CACxBC,EAAQC,EACR,MAGR,OAAOD,EEvGJ,IAAIE,EAAY,SAAUf,GAC7B,IAAIpB,EAASoB,EAAGpB,OAAQE,EAAoBkB,EAAGlB,kBAAmBkC,EAAWhB,EAAGgB,SAC5EjC,EAAWJ,EAAaC,EAAQ,CAAEE,kBAAmBA,IACzD,OAAO,uBAAakC,EAAU,CAAEC,IAAKlC","file":"chunks/0.chunk.js","sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { focusableElementDomString } from '../utils';\nimport { useCurrentRef } from './useCurrentRef';\n/**\n * A hook for trapping focus within an element. Returns a ref which can be given\n * to any element to trap focus within that element when `locked` is true.\n * @param locked When true, focus will be locked within the element you passed\n * the returned ref to.\n * @param options Options to control the focus trap.\n */\nexport function useFocusTrap(locked, options) {\n    if (locked === void 0) { locked = false; }\n    if (options === void 0) { options = {}; }\n    var focusLastOnUnlock = options.focusLastOnUnlock;\n    var focusRef = useRef(null);\n    // Get the focusable elements. Assumes that focusRef exists. DON'T CALL if\n    // you haven't asserted existance of focusRef.current.\n    var getFocusableElements = useCallback(function () {\n        return focusRef.current.querySelectorAll(focusableElementDomString);\n    }, []);\n    // Cycles tabs within the lock zone when enabled, or prevents default\n    // if there are no elements within the lock (rare edge case).\n    var lockFocus = useCallback(function (event) {\n        // Return if not locked, other key pressed, or no ref.\n        if (!locked || (event && event.key !== 'Tab') || !focusRef.current)\n            return;\n        var focusableElements = getFocusableElements();\n        // If no focusable elements, simply prevent tab default.\n        if (!focusableElements.length)\n            return event === null || event === void 0 ? void 0 : event.preventDefault();\n        var focusedItemIndex = findFocusableIndex(focusableElements, document.activeElement);\n        // If focused inside and initial call (no event), leave focused element.\n        if (focusedItemIndex !== -1 && !event)\n            return;\n        // If focused outside, or tabbing past last element, cycle to beginning.\n        if (focusedItemIndex === -1 || (!(event === null || event === void 0 ? void 0 : event.shiftKey) && focusedItemIndex === focusableElements.length - 1)) {\n            focusableElements[0].focus();\n            return event === null || event === void 0 ? void 0 : event.preventDefault();\n        }\n        // If tabbing backwards and focusing first element, cycle to end.\n        if ((event === null || event === void 0 ? void 0 : event.shiftKey) && focusedItemIndex === 0) {\n            focusableElements[focusableElements.length - 1].focus();\n            return event === null || event === void 0 ? void 0 : event.preventDefault();\n        }\n    }, [getFocusableElements, locked]);\n    // Ensure that user can not focus outside of lock. If an attempt is made\n    // and focusable elements exist inside, will focus first element inside.\n    var checkFocus = useCallback(function (event) {\n        var _a;\n        // Return if not locked or no focus ref.\n        if (!locked || !focusRef.current)\n            return;\n        // Blur focus target if no focusable elements.\n        var focusableElements = getFocusableElements();\n        if (!focusableElements.length)\n            return (_a = event.target) === null || _a === void 0 ? void 0 : _a.blur();\n        // Focus initial element if focused outside.\n        var focusedItemIndex = findFocusableIndex(focusableElements, event.target);\n        if (focusedItemIndex === -1)\n            return focusableElements[0].focus();\n    }, [getFocusableElements, locked]);\n    // Add document listeners for lock focus and check focus\n    useEffect(function () {\n        if (typeof window === 'undefined')\n            return;\n        document.addEventListener('keydown', lockFocus);\n        document.addEventListener('focusin', checkFocus);\n        return function () {\n            document.removeEventListener('keydown', lockFocus);\n            document.removeEventListener('focusin', checkFocus);\n        };\n    }, [checkFocus, lockFocus]);\n    // Keep the ref to focusLastOnUnlock fresh, prevents useEffect refresh.\n    var focusLastOnUnlockRef = useCurrentRef(focusLastOnUnlock);\n    // When locked is changed, will maybe store last element focused prior\n    // to lock being enabled, and will call lockFocus to focus first element\n    // if it exists. Returns when locked is disabled, and will focus prior\n    // element if stored (return focus to previous element).\n    useEffect(function () {\n        var _a;\n        if (typeof window === 'undefined')\n            return;\n        var lastFocusedElement;\n        if (locked) {\n            if (focusLastOnUnlockRef.current && !((_a = focusRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement))) {\n                lastFocusedElement = document.activeElement;\n                lockFocus();\n                return function () { return lastFocusedElement.focus(); };\n            }\n            lockFocus();\n        }\n        return;\n    }, [focusLastOnUnlockRef, lockFocus, locked]);\n    return focusRef;\n}\nexport function findFocusableIndex(elements, toFind) {\n    var index = -1;\n    if (!toFind)\n        return index;\n    for (var i = 0; i < elements.length; i++) {\n        if (elements[i] === toFind) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}\n","import { useEffect, useRef } from 'react';\nexport function useCurrentRef(toRef) {\n    var toRefRef = useRef(toRef);\n    useEffect(function () {\n        toRefRef.current = toRef;\n    });\n    return toRefRef;\n}\n","import { cloneElement } from 'react';\nimport { useFocusTrap } from '../../hooks';\nexport var FocusTrap = function (_a) {\n    var locked = _a.locked, focusLastOnUnlock = _a.focusLastOnUnlock, children = _a.children;\n    var focusRef = useFocusTrap(locked, { focusLastOnUnlock: focusLastOnUnlock });\n    return cloneElement(children, { ref: focusRef });\n};\n"],"sourceRoot":""}